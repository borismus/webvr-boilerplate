<!doctype html>
<!--
  Test swapping a canvas embedded in an existing web page layout into
  fullscreen and Fullscreen VR mode.
-->
<head>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!--handle iOS and android mobile
http://www.html5rocks.com/en/mobile/fullscreen/ -->
<!--ios fullscreen-->
<meta name="apple-mobile-web-app-capable" content="yes">
<!--android fullscreen-->
<meta name="mobile-web-app-capable" content="yes">
<!--default styles-->
<style>
/* CSS reset */
body, header, section, footer, figure, h1 {
  margin:0;
  border:0;
  padding:0;
}
/* basic body styles */
body {
  width: 100%;
  height: 100%;
  background-color: #000;
  color: #fff;
  margin: 0;
  padding: 0;
  overflow: hidden;
}
/* semantic element styles */
header, section, footer {
  width:100%;
  border-bottom: 1px solid green;
}

/*
 * The following classes are automatically
 * created by the Player. They can be changed
 * by including the following object in initialization of
 * the Player:
 * Player.playerClasses = {
     prefix: 'xxx', //applied to all Player elements.
     player: 'xxx-yyy', //only applied to Player <figure> element.
     caption: 'xxx-yyy' //only applied to the <figcaption> element.
     canvas: 'xxx-yyy',// only applied to PLayer <canvas> element.
     placeholder: 'xxx-yyy'
   };
 *
/*
 * webvr-boilerplate Player classes (created by Player)
 * If the Player detects these selectors, it will use them instead
 * of its default selector values in Player.playerClasses
 * Tested:
 * width:xxx%; height:100%;
 * width:xxx%; height:auto;
 * width:xxx px; height:yyy px;
 */
.webvr-player {
  border: 1px dotted red;
  width:80%;
  height:auto; /*100% ok*/
}

/* optional caption for scene in Player */
.webvr-player-caption {}

/* 3D drawing canvas within the Player */
.webvr-player-canvas {
  /*border: 1px solid yellow;*/
  /*width:100%;*/
  /*height:100%;*/
  /* have to use the !important to override local style set by three.js*/
  /*width: 80%!important;*/
  /*height: 80%!important;*/
  /*width:640px;*/
  /*height:480px;*/
}

.webvr-button-panel {
  border: 1px dotted orange;
}

/* Individual buttons in the control panel */
.webvr-button {}

/* Should always be invisible */
.webvr-placeholder {}


/* a generic class */
.bordered {
  margin: 4px;
}
</style>
</head>

<body>
  <div class="webvr-dom-container">
    <header>
      <h1>Page Header:WebVR in DOM</h1>
    </header>
    <main>
        <section id="content">
          <h2>Page Content Section</h2>
          <!--markup for webvr player-->
          <article>
            <h3>First VR Example</h3>
            <figure class="bordered">
              <canvas id="webvr-test-canvas">HTML5 Canvas not Supported, upgrade browser!</canvas>
            </figure>
          </article>
          <!--a second webvr player-->
          <article>
            <h3>Second VR Example</h3>
            <figure class="bordered">
              <canvas id="webvr-text-canvas">HTML5 Canvas not supported, upgrade!</canvas>
              <figcaption>WebVR 3D Text</figcaption>
            </figure>
          </article>
      </section>
      <footer>
        <h2>Page Footer</h2>
      </footer>
    </main>
  </div>
<!--scripts at bottom of body-->
<script src="../bower_components/threejs/build/three.js"></script>
<!--add TextGeometry-->
<script src="../bower_components/threejs/examples/js/controls/OrbitControls.js"></script>
<script src="../bower_components/threejs/examples/js/utils/FontUtils.js"></script>
<script src="../bower_components/threejs/examples/js/geometries/TextGeometry.js"></script>
<!--typeface.js fonts for scenes-->
<script src="../bower_components/threejs/examples/fonts/optimer_regular.typeface.js"></script>
<script src="../bower_components/threejs/examples/fonts/optimer_bold.typeface.js"></script>
<!--add VR controls-->
<script src="../bower_components/threejs/examples/js/controls/VRControls.js"></script>
<script src="../bower_components/threejs/examples/js/effects/VREffect.js"></script>
<script src="../bower_components/webvr-polyfill/build/webvr-polyfill.js"></script>
<script src="../build/webvr-manager.js"></script>

<script>
// Wrap setup in DOMContentLoaded event so DOM can render, and CSS .getComputedStyle works
document.addEventListener('DOMContentLoaded', function() {

  /**
   * ===================================
   * FIRST RENDERED SCREEN.
   * SPINNING CUBE.
   * ===================================
   */

  // Setup three.js WebGL renderer
  var renderer = new THREE.WebGLRenderer({
    canvas:document.getElementById('webvr-test-canvas'),
    antialias: true
  });
  renderer.setPixelRatio(window.devicePixelRatio);

  // Use the CSS computed style for this <canvas>
  var canvasStyle = {
    width:parseInt(getComputedStyle(renderer.domElement).width),
    height:parseInt(getComputedStyle(renderer.domElement).height)
  };

  // Create a three.js scene.
  var scene = new THREE.Scene();

  // Create a three.js camera.
  var camera = new THREE.PerspectiveCamera(75, canvasStyle.width / canvasStyle.height, 0.1, 10000);

  // Apply VR headset positional data to camera.
  var controls = new THREE.VRControls(camera);

  // Apply VR stereo rendering to renderer.
  var effect = new THREE.VREffect(renderer);
  effect.setSize(canvasStyle.width, canvasStyle.height);

  // Adjust our element
  //renderer.setSize(canvasStyle.width, canvasStyle.height); //TODO: IS THIS NEEDED?

  // Add a repeating grid as a skybox.
  var boxWidth = 5;
  var texture = THREE.ImageUtils.loadTexture(
    '../img/box.png'
  );
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(boxWidth, boxWidth);

  var geometry = new THREE.BoxGeometry(boxWidth, boxWidth, boxWidth);
  var material = new THREE.MeshBasicMaterial({
    map: texture,
    color: 0x01BE00,
    side: THREE.BackSide
  });

  var skybox = new THREE.Mesh(geometry, material);
  scene.add(skybox);

  /**
   * Create a VR manager helper to enter and exit VR mode.
   * Attch to 'window' because we are in a DOMContentLoaded callback.
   * Since we don't supply the setToCanvasSize in params, the Player
   * will automatically re-scale to the computed CSS size.
   */
   window.manager = new WebVRManager(renderer, effect, {hideButton: false});

   // Create 3D objects.
   var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
   var material = new THREE.MeshNormalMaterial();
   var cube = new THREE.Mesh(geometry, material);

   // Position cube mesh
   cube.position.z = -1;

   // Add cube mesh to your three.js scene.
  scene.add(cube);

  // Request animation frame loop function.
  function animate(timestamp) {
  // Apply rotation to cube mesh.
  cube.rotation.y += 0.01;

  // Update VR headset position and apply to camera.
  controls.update();

  // Render the scene through the manager.
  manager.render(scene, camera, timestamp);

  requestAnimationFrame(animate);
};

// Reset the position sensor when 'z' pressed.
function onKey(event) {
  if (event.keyCode == 90) { // z
    controls.resetSensor();
  }
};
  window.addEventListener('keydown', onKey, true);

  // Do ONE resize event to properly set up the scene, after manager is initialized.
  //TODO: this is fuzzy for some reason, unless we start with the resizeIfNeeded()
  manager.resizeIfNeeded_(camera);
  // Begin listening for resize events (separate from animation loop).
  manager.listenResize(camera);

  // Begin animating.
  animate();

/**
 * ===================================
 * SECOND RENDERED SCREEN.
 * VECTOR TEXT.
 * From: http://andrewray.me/threejs-examples/font-example/js/font-example.js
 * ===================================
 */

 var textscene = new THREE.Scene();

  // Set up the camera.
  var SCREEN_WIDTH = 800, SCREEN_HEIGHT = 300;
  var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;

  var textcamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
  textscene.add(textcamera);

  textcamera.position.set(0,0,1000);
  textcamera.lookAt(textscene.position);

  var textrenderer = new THREE.WebGLRenderer({
    canvas:document.getElementById('webvr-text-canvas'),
    antialias: true
  });
  textrenderer.setPixelRatio(window.devicePixelRatio);
  //////////textrenderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

// Set up the controls.
  textcontrols = new THREE.OrbitControls(textcamera, textrenderer.domElement);

  // Set up the light.
  var textlight = new THREE.PointLight(0xffffff);
  textlight.position.set(0,0,1000);
  textscene.add(textlight);
  var textmaterial = new THREE.MeshPhongMaterial({
      color: 0xdddddd
  });
  var textGeom = new THREE.TextGeometry('WebVR Figure!', {
      font: 'Optimer', weight: 'bold'// Must be lowercase!
  });
  var textMesh = new THREE.Mesh(textGeom, material);
  // Width of generated text (optional).
  textGeom.computeBoundingBox();
  textGeom.textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
  textMesh.position.set(0 * textGeom.textWidth, -100, 0);

  // Add text to scene.
  textscene.add(textMesh);

  // add 3D text beveled and sized.
  var material2 = new THREE.MeshPhongMaterial({
      color: 0x00ff00
  });
  var textGeom2 = new THREE.TextGeometry('WebVR Figure!', {
      size: 60, height: 20, curveSegments: 3,
      font: 'Optimer', weight: 'bold',
      bevelThickness: 3, bevelSize: 3, bevelEnabled: true
  });
  var textMesh2 = new THREE.Mesh(textGeom2, material2);

  textGeom2.computeBoundingBox();
  var textWidth2 = textGeom2.boundingBox.max.x - textGeom2.boundingBox.min.x;
  textMesh2.position.set(-1.0 * textWidth2, -100, 0);
  textscene.add(textMesh2);

  // Apply VR stereo rendering to renderer.
  var texteffect = new THREE.VREffect(textrenderer);
  texteffect.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

  // Create a VR manager helper to enter and exit VR mode.
  // Attch to 'window' because we are in a DOMContentLoaded callback.
  window.textmanager = new WebVRManager(textrenderer, texteffect, {hideButton: false});

  // First default resize.
  // Do ONE resize event to properly set up the scene, after manager is initialized.
  //TODO: this is fuzzy for some reason, unless we start with the resizeIfNeeded()
  textmanager.resizeIfNeeded_(textcamera);
  // Begin listening for resize events (separate from animation loop).
  textmanager.listenResize(textcamera);

  function textrender() {
    textrenderer.render(textscene, textcamera);
  }

  function textanimate() {
    window.requestAnimationFrame(textanimate);
    textrender();
  }

  textanimate();

}); //end of DOMContentLoaded

</script>
</body>
</html>
